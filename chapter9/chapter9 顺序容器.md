
# 9.1 顺序容器类型

顺序容器类型（page 292）

|容器|说明|
|:-|:-|
|`vector`|可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。`vector`和`string`将元素保存在连续的内存空间。|
|`string`|与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快|
|`deque`|双端队列。支持快速随机访问。在头尾位置插入/删除速度很快|
|`list`|双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快|
|`forward_list`|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。|
|`array`|固定大小数组。支持快速随机访问。**不能添加或删除元素**|

通常，使用`vector`是最好的选择，除非你有更好的理由选择其他容器。

# 9.2 容器库概览

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。

所有容器都支持的操作（page 295）

|||
|:-|:-|
|**类型别名**||
|`iterator`|此容器类型的迭代器类型|
|`const_iterator`|可以读取元素，但不能修改元素的迭代器|
|`size_type`|无符号整数类型，足够保存此种容器类型最大可能容器的大小|
|`difference_type`|带符号整数，足够保存两个迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型；与`value_type&`含义相同|
|`const_reference`|元素的`const`左值类型（即，`const value_type&`|
|**构造函数**||
|`C c;`|默认构造函数，构造空容器|
|`C c1(c2);`|构造`c2`的拷贝`c1`|
|`C c(b, e);`|构造`c`，将迭代器`b`和`e`指定范围内的元素拷贝到`c`。**`array`不支持**。|
|`C c{a, b, c, ...};`|列表初始化`c`|
|**赋值与`swap`**||
|`c1 = c2`|将`c1`中的元素替换为`c2`中的元素|
|`c1 = {a, b, c, ...}`|将`c1`中的元素替换为列表中元素（不适用于`array`）|
|`a.swap(b)`|交换`a`和`b`的元素|
|`swap(a, b)`|与`a.swap(b)`等价|
|**大小**||
|`c.size()`|`c`中元素的数目（不支持`forward_list`）|
|`c.max_size()`|`c`可保存的最大元素数目|
|`c.empty()`|若`c`中存储了元素，返回`false`，否则返回`true`|
|**添加/删除元素（不适用于`array`）**||
|注：在不同容器中，这些操作的接口都不同||
|`c.insert(args)`|将`args`中的元素拷贝仅`c`|
|`c.emplace(inits)`|使用`init`构造`c`中的一个元素。`init`与元素类型的某一构造器的参数列表相匹配。|
|`c.erase(args)`|删除`args`指定的元素|
|`c.clear()`|删除`c`中的所有元素，返回`void`|
|关系元素符||
|`==, !=`|所有容器都支持相等（不等）运算符|
|`<, <=, >, >=`|关系运算符（无序关联容器不支持）|
|**获取迭代器**||
|`c.begin(), c.end()`|返回指向`c`的首元素和尾元素之后位置的迭代器|
|`c.cbegin(), c.cend()`|返回`const_iterator`|
|反向容器的额外成员（不支持`forward_list`||
|`reverse_iterator`|按逆序寻址元素的迭代器|
|`c.rbegin(), c.rend()`|返回`c`的尾元素和首元素之前位置的迭代器|
|`c.crbegin(), c.crend()`|返回`const_reverse_iteratr`| 


## 9.2.1 迭代器

迭代器范围是左闭右开区间：$[begin, end)$。


## 9.2.2 容器类型成员

通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。

```c++
list<string>::iterator iter;
vector<int>::difference_type count;
```

## 9.2.3 `begin`和`end`成员

## 9.2.4 容器定义和初始化

|||
|:-|:-|
|`C c`|默认构造函数。如果`C`是一个`array`， 则`c`中元素按默认方式初始化；否则`c`为空|
|`C c1(c2)` <br> `C c1 = c2`|`c1`初始化为`c2`的拷贝，`c1`和`c2`必须有相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同的大小|
|`C c{a, b, c, ...}` <br> `C c = {a, b, c, ...}`|`c`初始化为初始化列表中元素的拷贝。列表中元素的类型必须与`C`的元素类型**相容**。对于`array`类型，列表中元素的数目必须等于或小于`array`的大小，任何遗漏的元素都进行值初始化。|
|`C c(b, e)`|`c`初始化为`b`和`e`指定范围中的元素的拷贝。范围中元素的类型必须与`C`的元素类型**相容**。（`array`不适用）|
|只有顺序容器（不包括`array`）的构造函数才能接受大小参数||
|`C seq(n)`| `seq`包含`n`个元素，这些元素进行了值初始化；此构造函数是`explicit`的。（`string`不适用）
|`C seq(n, t)`|`seq`包含`n`个初始化值为`t`的元素|


标准库`array`的大小也是类型的一部分。标准库`array`可以进行赋值和拷贝。
```c++
array<int, 42>; # 进行值初始化
```


## 9.2.5 赋值和`swap`

|||
|:-|:-|
|`c1 = c2`|将`c1`中的元素替换为`c2`中元素的拷贝。`c1`和`c2`必须具有相同的类型|
|`c={a, b, c, ...}`|将`c1`中元素替换为初始化列表中元素的拷贝。（`array`不适用|
|`swap(c1, c2)`<br>`c1.swap(c2)`|交换`c1`和`c2`中的元素。`c1`和`c2`必须具有相同的类型。`swap`通常比从`c2`向`c1`拷贝元素快的多。|
|`assign操作不适用于关联容器和`assign`||
|`seq.assign(b, e)`|将`seq`中的元素替换为`b`和`e`所表示的范围中的元素|
|`seq.assign(il)`|将`seq`中的元素替换为初始化列表`il`中的元素|
|`seq.assign(n, t)`|将`seq`中的元素替换为`n`个值为`t`的元素|


赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。`swap`操作将容器内容交换不会导致指向同期的迭代器、引用和指针失效（`array`和`string`除外）。


## 9.2.6 容器大小操作

## 9.2.7 关系运算符

容器的相等运算符实际上是使用元素的`==`运算符实现比较的，而其他关系运算符是使用元素的`<`运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。


# 9.3 顺序容器操作

## 9.3.1 向顺序容器添加元素

|||
|:-|:-|
|`c.push_back(t)`<br>`c.emplace_back(t)`|在`c`的尾部创建一个值为`t`或者由`args`创建的元素。返回`void`|
|`c.push_front(t)`<br>`c.emplace_front(t)`|在`c`的头部创建一个值为`t`或者由`arg`创建的元素。返回`void`|
|`c.insert(p, t)`<br>`c.emplace(p, args)`|在迭代器`p`指向的元素**之前**创建一个值为`t`或者由`args`创建的元素。返回指向新添加的元素的迭代器。|
|`c.insert(p, n, t)`|在迭代器`p`指向的元素之前插入`n`个值为`t`的元素，返回指向新添加的第一个元素的迭代器；若`n`为0，则返回`p`|
|`c.insert(p, b, e)`|将迭代器`b`和`e`指定的范围内的元素插入到迭代器`p`指向的元素之前。`b`和`e`不能指向`c`中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p|
|`c.insert(p, il)`|`il`是一个花括号包围的元素值列表。将这些给定值插入到迭代器`p`指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回`p`|

向一个`vector`，`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效。