

# 4.1 基础

#### 左值和右值

**当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**

**在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用。** 当一个左值被当做右值使用时，实际使用的是它的内容（值）。

- 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个**左值**。
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个**右值**。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是**左值**。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，**其前置版本所得的结果也是左值**。

## 4.1.3 求值顺序

### 建议：处理复合表达式

1. 拿不准的时候最好用括号来强制表达式的组合关系复合程序逻辑的要求。
2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，规则2无效，譬如：`*++iter`。


# 4.2 算数运算符

算数运算符满足左结合律。算数运算符的运算对象和求值结果都是右值。

```c++
int in = 1024;
int k = -i;     // k是-1024
bool b = true;
bool b2 = -b    // b2是true！-b将bool提升为int，得到-1，-1赋给b2是强制转换为bool类型，得到true
```

`(-m)/n = m/(-n) = -(m/n)`，`m%(-n) = m%n`，`(-m)%n = -(m%n)`


# 4.3 逻辑和关系运算符

关系运算符作用于算数类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则为真。对于这两类运算符来说，运算对象和求值结果都是**右值**。

`&&`和`||`短路求值。


# 4.4 赋值运算符

- 赋值运算符的左侧运算对象必须是一个**可修改**的**左值**。

    ```c++
    int i = 0, j = 0, k = 0;    // 初始化而非赋值
    const int ci = i;           // 初始化而非赋值
    1024 = k;                   // 错误：字面值是右值
    i + j = k;                  // 错误：算数表达式是右值
    ci = k;                     // 错误：ci是常量（不可修改的）左值
    ```

- 赋值运算的结果是它的左侧运算对象，并且是一个左值。

- 如果赋值运算符的左右两个运算符类型不同，则右侧运算对象将转换成左侧运算对象。
    ```c++
    k = 3.14159                 // 结果：类型是int，值是3
    ```

- 赋值运算符号满足**右结合律**。对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同，或者可由右边的类型转换得到。
  
    ```c++
    int ival, jval, *pval;
    ival = jval = 0;            // 正确：都被赋值为0
    ival = pval = 0;            // 错误：不能把指针赋给int
    string s1, s2;
    s1 = s2 = "OK";             // 字符串字面值"OK"转换成string对象
    ```

- 赋值运算符优先级较低，所以通常需要给赋值部分加上括号。

    ```c++
    // 较好的写法
    int i;
    while ((i = get_value() != 42)) {
        // 其他处理……
    }

    // 等价于
    int i = get_value();
    while (i != 42) {
        // 其他处理……
        i = get_value();
    }
    ```

# 4.5 递增和递减运算符

前置版本，首先将运算对象加1（或减1），然后**将改变后的对象作为求值结果**。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象**改变之前那个值的副本**。除非必须，否则不用递增递减运算符的后置版本。

```c++
auto pbeg = v.begin();
while (pbeg != v.end() && *beg >= 10) {
    cout << *pbeg++ <<endl;     // 输出当前值并将pbeg向前移动一个元素
}
```

# 4.6 成员访问运算符

```c++
string s1 = "a string", *p = &s1;
auto n = s1.size();
n = (*p).size();
n = p -> size();            // 与上式等价     
```

# 4.7 条件运算符

`cond ? expr1:expr2`

`cond`为真对`expr1`求值并返回该值，否则对`expr2`求值并返回该值。

```c++
string finalgrade;
finalgrade = (grade > 90) ? "high pass"
                          : (grade < 60) ? "fail":"pass";
```


# 4.8 位运算符

关于符号位如何处理没有明确的规定，所以强烈建议**仅将位运算符用于处理无符号类型。**

移位运算符（又叫IO运算符）满足左结合律。


# 4.9 sizeof运算符

`sizeof`运算符返回一条表达式或一个类型名字所占的字节数。与解引用、负号等一元运算符处于同一优先级。

```c++
Sales_data data, *p;
sizeof(Sales_data);
sizeof data;
sizeof p;
sizeof *p;
sizeof data.revenue;
sizeof Sales_data::revenue; // 无需提供具体的对象即可获取成员的size
```

`sizeof`运算符的结果部分地依赖于其作用的类型：

- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1。
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小。
- 对指针执行`sizeof`运算得到的**指针本身**所占空间的大小。
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需有效，因为`sizeof`并不实际计算其运算对象的值。
- 对数组执行`sizeof`运算得到整个数组所占空间的大小，等价对数组中所有的元素各执行一次`sizeof`运算并将所得结果求和。**`sizeof`不会把数组转换成指针来处理。**
- 对`string`对象或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占用多少空间。

```c++
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
int arr2[sz];   # sizeof返回常量表达式，可以作为索引
```

# 4.10  逗号运算符

与逻辑与、逻辑或及条件运算符一样，逗号运算符也规定了运算对象的求值顺序。对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算真正的结果是**右侧表达式的值**。如果右侧运算对象是左值，那么最终的求值结果也是左值。

```c++
vector<int>::size_type cnt = ivec.size();
for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```

# 4.11 类型转换

暂略

# 4.12 运算符优先级表

page 147